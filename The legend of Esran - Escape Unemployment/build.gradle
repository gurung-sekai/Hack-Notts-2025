plugins {
    id 'application'
}

repositories {
    mavenCentral()
}

def javaFxLibDir = file("${rootProject.projectDir}/../javafx-sdk-21.0.2/lib")
def isWindowsHost = System.properties['os.name']?.toLowerCase()?.contains('win') ?: false

dependencies {
    implementation fileTree(dir: javaFxLibDir, include: ['*.jar'])
}

application {
    mainClass = 'Battle.fx.FxMain'
    applicationDefaultJvmArgs = [
            '--module-path', javaFxLibDir.absolutePath,
            '--add-modules', 'javafx.controls'
    ]
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

sourceSets {
    main {
        java {
            srcDirs = ['src']
        }
    }
}

// Ensure all Java executions (run, test) see the JavaFX modules.
[JavaExec, Test].each { taskType ->
    tasks.withType(taskType).configureEach {
        jvmArgs '--module-path', javaFxLibDir.absolutePath,
                '--add-modules', 'javafx.controls'
    }
}

tasks.withType(JavaCompile).configureEach {
    options.incremental = false
    doFirst {
        def dir = destinationDirectory.get().asFile
        if (dir.exists()) {
            def attempts = 0
            def cleared = false
            while (!cleared && attempts < 5) {
                attempts++
                project.delete(dir)
                cleared = !dir.exists()
                if (!cleared) {
                    logger.warn("Attempt ${attempts} to clear stale classes in ${dir} is still pending; retrying...")
                    System.gc()
                    sleep(150)
                }
            }
            if (!cleared) {
                logger.warn("Proceeding with existing compiled classes under ${dir} after repeated cleanup attempts.")
            }
        }
    }
    if (isWindowsHost) {
        outputs.doNotTrackState("Windows retains file locks on compiled classes; skip stale output cleanup to avoid build flakiness.")
    }
}
