import org.gradle.api.Project

plugins {
    id 'application'
}

static File locateJavaFxLib(Project project) {
    List<File> candidates = [
            project.file("${project.rootDir}/javafx-sdk-21.0.2/lib"),
            project.file("${project.rootDir}/javafx-sdk-25.0.1/lib"),
            project.file("${project.rootDir}/javafx-sdk/lib"),
            project.file("${project.projectDir}/javafx-sdk-21.0.2/lib"),
            project.file("${project.projectDir}/javafx-sdk-25.0.1/lib"),
            project.file("${project.projectDir}/javafx-sdk/lib"),
            project.file("${project.projectDir}/../javafx-sdk-21.0.2/lib"),
            project.file("${project.projectDir}/../javafx-sdk-25.0.1/lib"),
            project.file("${project.projectDir}/../javafx-sdk/lib"),
            project.file("${project.projectDir}/lib/javafx"),
            project.file("${project.rootDir}/lib/javafx")
    ]
    return candidates.find { it.exists() && it.isDirectory() }
}

def javaFxLibDir = locateJavaFxLib(project)
if (javaFxLibDir == null) {
    throw new GradleException("JavaFX SDK jars not found. Place an extracted sdk under one of: " +
            "javafx-sdk-21.0.2/lib, javafx-sdk-25.0.1/lib, javafx-sdk/lib, or lib/javafx relative to the project root.")
}

def isWindowsHost = System.properties['os.name']?.toLowerCase()?.contains('win') ?: false

def javaFxJars = javaFxLibDir.listFiles()?.findAll { it.name.endsWith('.jar') } ?: []
if (javaFxJars.isEmpty()) {
    throw new GradleException("JavaFX SDK directory ${javaFxLibDir} does not contain any .jar files.")
}

dependencies {
    implementation files(javaFxJars)
}

application {
    mainClass = 'Battle.fx.FxMain'
    applicationDefaultJvmArgs = [
            '--module-path', javaFxLibDir.absolutePath,
            '--add-modules', 'javafx.controls'
    ]
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

sourceSets {
    main {
        java {
            srcDirs = ['src']
        }
    }
}

// Ensure all Java executions (run, test) see the JavaFX modules.
[JavaExec, Test].each { taskType ->
    tasks.withType(taskType).configureEach {
        jvmArgs '--module-path', javaFxLibDir.absolutePath,
                '--add-modules', 'javafx.controls'
    }
}

def staleHeaderDirectories = []

tasks.withType(JavaCompile).configureEach { task ->
    options.incremental = false

    // Gradle defaults JNI header generation to build/generated/sources/headers/java/<sourceSet>,
    // which lives inside the OneDrive-synced project directory for Windows users. OneDrive tends
    // to lock those files, and Gradle fails the build when it cannot delete the directory during
    // stale output cleanup. Point the headers at the system temp directory instead so the cleanup
    // happens outside of OneDrive's control.
    def originalHeaderDir = options.headerOutputDirectory.orNull?.asFile
    def tempHeaderRoot = new File(System.getProperty('java.io.tmpdir'),
            "hacknotts-headers/${project.name}/${task.name}")
    options.headerOutputDirectory = tempHeaderRoot

    doLast {
        if (tempHeaderRoot.exists()) {
            tempHeaderRoot.deleteDir()
        }
    }

    if (isWindowsHost) {
        if (originalHeaderDir != null) {
            staleHeaderDirectories << originalHeaderDir
        }
        task.doNotTrackState("Avoid Gradle stale output cleanup on Windows when JNI headers live outside the project.")
    }
}

if (isWindowsHost) {
    gradle.buildFinished {
        staleHeaderDirectories.findAll { it != null }.each { File staleDir ->
            if (staleDir.exists()) {
                try {
                    project.delete(staleDir)
                } catch (Exception ignored) {
                    logger.info("JNI header directory ${staleDir} is still locked; leaving it in place.")
                }
            }
        }
    }
}

if (!isWindowsHost) {
    def purgeJavaClasses = tasks.register('purgeJavaClasses') {
        group = 'build setup'
        description = 'Removes compiled Java outputs before a fresh compilation on non-Windows hosts.'
        doLast {
            def classesDir = file("${buildDir}/classes")
            if (classesDir.exists()) {
                logger.lifecycle("Deleting ${classesDir} before recompiling Java sources.")
                project.delete(classesDir)
            }
        }
    }

    tasks.withType(JavaCompile).configureEach { task ->
        task.dependsOn(purgeJavaClasses)
    }
}
